/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package sm.cmr.iu;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import sm.cmr.eventos.LienzoEvent;
import sm.cmr.eventos.LienzoListener;
import sm.cmr.graficos.Ellipse_Forma;
import sm.cmr.graficos.FormasSM;
import sm.cmr.graficos.GeneralPath_Forma;
import sm.cmr.graficos.Herramienta;
import static sm.cmr.graficos.Herramienta.TRAZO;
import sm.cmr.graficos.Line_Forma;
import sm.cmr.graficos.QuadCurve_Forma;
import sm.cmr.graficos.Rectangle_Forma;
import sm.cmr.graficos.Smile_Forma;

/**
 * Clase que implementa un Lienzo para poder dibujar y mover figuras
 *
 * @author Cesar Muñoz Reinoso
 */
public class Lienzo2D extends javax.swing.JPanel {

    /**
     * Punto de inicio en dibujo de figura
     */
    protected Point2D punto_inicio;

    /**
     * Punto final en dibujo de figura
     */
    protected Point2D punto_final;

    /**
     * Punto de control en dibujo de curva
     */
    protected boolean punto_control;
    /**
     * Color seleccionado
     */
    protected Color color;

    /**
     * Trazo seleccionado
     */
    protected Stroke trazo;

    /**
     * Composite seleccionado
     */
    protected Composite comp;

    /**
     * Render seleccionado
     */
    protected RenderingHints render;

    /**
     * Herramienta seleccionada
     */
    protected Herramienta herramienta;

    /**
     * Lista de Formas
     */
    protected List<FormasSM> vShape;

    /**
     * Figura actual
     */
    protected FormasSM forma;

    /**
     * Herramienta mover seleccionada
     */
    protected boolean mover;

    /**
     * Relleno seleccionado
     */
    protected boolean relleno;

    /**
     * Alisar seleccionado
     */
    protected boolean alisado;

    /**
     * Discontinua seleccionado
     */
    protected boolean discontinua;

    /**
     * Figura para el area delimitada en lienzo
     */
    protected Shape area_clip;

    /**
     * Distancia de discontinuidad en modo discontinuo
     */
    protected float distancia_discontinuidad[] = {2.5f};

    /**
     * Valor de grosor seleccionado
     */
    protected int grosor;

    /**
     * Imagen del Lienzo
     */
    BufferedImage img;

    /**
     * Listener del Lienzo
     */
    ArrayList<LienzoListener> lienzoEventListeners;

    /**
     * Constructor del lienzo
     */
    public Lienzo2D() {
        this.lienzoEventListeners = new ArrayList();
        initComponents();

        color = Color.BLACK;
        trazo = new BasicStroke();
        comp = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f);
        render = new RenderingHints(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
        herramienta = Herramienta.LINEA;
        vShape = new ArrayList();
        forma = null;
        mover = false;
        alisado = false;
        punto_control = false;
        discontinua = false;
        area_clip = new Rectangle2D.Float();
        grosor = 1;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Crea nuevas figuras cuando se hace click en el lienzo
     *
     * @param evt
     */
    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        if (mover) {
            forma = (FormasSM) getFiguraSeleccionada(evt.getPoint());
        } else {
            this.punto_inicio = evt.getPoint();
            switch (this.herramienta) {
                case LINEA -> {
                    forma = new Line_Forma(evt.getPoint(), evt.getPoint());
                    setAtributos(forma, false);
                }
                case RECTANGULO -> {
                    forma = new Rectangle_Forma((float) evt.getPoint().getX(), (float) evt.getPoint().getY(), 0, 0);
                    setAtributos(forma, true);
                }
                case ELIPSE -> {
                    forma = new Ellipse_Forma((float) evt.getPoint().getX(), (float) evt.getPoint().getY(), 0, 0);
                    setAtributos(forma, true);
                }
                case CURVA -> {
                    if (!punto_control) {
                        forma = new QuadCurve_Forma((float) evt.getPoint().getX(), (float) evt.getPoint().getY(), (float) evt.getPoint().getX(), (float) evt.getPoint().getY(), (float) evt.getPoint().getX(), (float) evt.getPoint().getY());
                        setAtributos(forma, false);
                    }
                }
                case TRAZO -> {
                    forma = new GeneralPath_Forma(GeneralPath.WIND_EVEN_ODD, 1);
                    (forma).getGeneralPath().moveTo((float) evt.getPoint().getX(), (float) evt.getPoint().getY());
                    setAtributos(forma, false);
                }
                case SMILE -> {
                    forma = new Smile_Forma(evt.getPoint());
                    setAtributos(forma, true);
                }
            }
            vShape.add(forma);
            if (!punto_control) {
                notifyShapeAddedEvent(new LienzoEvent(this, forma, color));
            }
            this.repaint();
        }
    }//GEN-LAST:event_formMousePressed

    /**
     * Crea nuevas figuras cuando se desliza el raton en el lienzo
     *
     * @param evt
     */
    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        if (mover) {
            if (forma != null && forma instanceof Line_Forma) {
                (forma).getLine().setLocation(evt.getPoint());
            } else if (forma != null && forma instanceof Rectangle_Forma) {
                (forma).getRectangulo().setLocation(evt.getPoint());
            } else if (forma != null && forma instanceof Ellipse_Forma) {
                (forma).getElipse().setLocation(evt.getPoint());
            } else if (forma != null && forma instanceof QuadCurve_Forma) {
                (forma).getCurva().setLocation(evt.getPoint());
            } else if (forma != null && forma instanceof GeneralPath_Forma) {
                (forma).getGeneralPath().setLocation(evt.getPoint());
            } else if (forma != null && forma instanceof Smile_Forma) {
                (forma).getSmile().setLocation(evt.getPoint());
            }
        } else {
            this.punto_final = evt.getPoint();
            switch (this.herramienta) {
                case LINEA -> {
                    if (this.punto_inicio != null && this.punto_final != null) {
                        (forma).getLine().setLine(this.punto_inicio, this.punto_final);
                    }
                }
                case RECTANGULO -> {
                    if (this.punto_inicio != null && this.punto_final != null) {
                        (forma).getRectangulo().setRect(Math.min(this.punto_inicio.getX(), this.punto_final.getX()), Math.min(this.punto_inicio.getY(), this.punto_final.getY()),
                                Math.abs(this.punto_inicio.getX() - this.punto_final.getX()), Math.abs(this.punto_inicio.getY() - this.punto_final.getY()));
                    }
                }
                case ELIPSE -> {
                    if (this.punto_inicio != null && this.punto_final != null) {
                        (forma).getElipse().setFrame(Math.min(this.punto_inicio.getX(), this.punto_final.getX()), Math.min(this.punto_inicio.getY(), this.punto_final.getY()),
                                Math.abs(this.punto_inicio.getX() - this.punto_final.getX()), Math.abs(this.punto_inicio.getY() - this.punto_final.getY()));
                    }
                }
                case CURVA -> {
                    if (!punto_control) {
                        if (this.punto_inicio != null && this.punto_final != null) {
                            (forma).getCurva().setCurve(this.punto_inicio.getX(), this.punto_inicio.getY(), ((this.punto_inicio.getX() + this.punto_final.getX()) / 2.0), ((this.punto_inicio.getY() + this.punto_final.getY()) / 2.0), this.punto_final.getX(), this.punto_final.getY());
                        }
                    } else {
                        if (this.punto_inicio != null && this.punto_final != null) {
                            (forma).getCurva().setCurve((float) (forma).getCurva().getX1(), (float) (forma).getCurva().getY1(), this.punto_final.getX(), this.punto_final.getY(), (float) (forma).getCurva().getX2(), (float) (forma).getCurva().getY2());
                        }
                    }
                }
                case TRAZO -> {
                    if (this.punto_inicio != null && this.punto_final != null) {
                        (forma).getGeneralPath().lineTo(this.punto_final.getX(), this.punto_final.getY());
                    }
                }
            }
        }
        this.repaint();
    }//GEN-LAST:event_formMouseDragged
    /**
     * Cambia el punto de control cuando se deja de hacer click en el lienzo,
     * para saber en que fase de la creacion de la curva estamos
     *
     * @param evt
     */
    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        if (this.herramienta == Herramienta.CURVA) {
            punto_control = !punto_control;
        }
    }//GEN-LAST:event_formMouseReleased

    /**
     *
     * @param g
     */
    @Override
    public void paint(Graphics g) {
        super.paint(g);
        Graphics2D g2d = (Graphics2D) g;
        g2d.clip(area_clip);
        if (img != null) {
            g2d.drawImage(img, 0, 0, this);
        }
        if (vShape != null) {
            for (FormasSM s : vShape) {
                s.paint(g2d);
            }
        }
    }

    /**
     * Función que dibuja las figuras en el lienzo de forma definitiva,
     * eliminandolas del vector de figuras.
     *
     * @param vvShape
     */
    public void volcarFiguras(List<FormasSM> vvShape) {
        img = this.getImagen(true);
        vShape.removeAll(vvShape);
    }

    /**
     * Devuelve la figura seleccionada en el punto
     *
     * @param p
     */
    private FormasSM getFiguraSeleccionada(Point2D p) {
        for (FormasSM s : vShape) {
            if (s.contains(p)) {
                return s;
            }
        }
        return null;
    }

    /**
     * Establece el color
     *
     * @param color
     */
    public void setColor(Color color) {
        this.color = color;
    }

    /**
     * Devuelve el color
     *
     * @return
     */
    public Color getColor() {
        return color;
    }

    /**
     * Establece el trazo
     *
     * @param grosor
     */
    public void setTrazo(int grosor) {
        if (discontinua) {
            trazo = new BasicStroke(grosor, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 5.0f, distancia_discontinuidad, 0.0f);
        } else {
            trazo = new BasicStroke(grosor);
        }
        this.grosor = grosor;
    }

    /**
     * Devuelve el trazo
     *
     * @return
     */
    public Stroke getTrazo() {
        return trazo;
    }

    /**
     * Establece la herramienta a utilizar
     *
     * @param herramienta
     */
    public void setHerramienta(Herramienta herramienta) {
        this.herramienta = herramienta;
    }

    /**
     * Devuelve la herramienta activa
     *
     * @return
     */
    public Herramienta getHerramienta() {
        return herramienta;
    }

    /**
     * Establece el relleno
     *
     * @param relleno
     */
    public void setRelleno(boolean relleno) {
        this.relleno = relleno;
    }

    /**
     * Devuelve si tiene relleno
     *
     * @return
     */
    public boolean getRelleno() {
        return relleno;
    }

    /**
     * Establece si se debe mover la figura
     *
     * @param mover
     */
    public void setMover(boolean mover) {
        this.mover = mover;
    }

    /**
     * Devuelve si el modo mover esta activo
     *
     * @return
     */
    public boolean getMover() {
        return mover;
    }

    /**
     * Establece el vector de figura
     *
     * @param vShape
     */
    public void setvShape(List<FormasSM> vShape) {
        this.vShape = vShape;
    }

    /**
     * Devuelve el vector de figura
     *
     * @return
     */
    public List<FormasSM> getvShape() {
        return vShape;
    }

    /**
     * Establece la composición
     *
     * @param comp
     */
    public void setComp(Composite comp) {
        this.comp = comp;
    }

    /**
     * Devuelve la composición
     *
     * @return
     */
    public Composite getComp() {
        return comp;
    }

    /**
     * Establece el alisado
     *
     * @param alisado
     */
    public void setAlisado(boolean alisado) {
        this.alisado = alisado;
        if (alisado) {
            render = new RenderingHints(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        } else {
            render = new RenderingHints(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        }
    }

    /**
     * Devuelve el alisado
     *
     * @return
     */
    public boolean getAlisado() {
        return alisado;
    }

    /**
     * Establece el render
     *
     * @param render
     */
    public void setRender(RenderingHints render) {
        this.render = render;
    }

    /**
     * Devuelve el render
     *
     * @return
     */
    public RenderingHints getRender() {
        return render;
    }

    /**
     *
     * @param img
     */
    public void setImagen(BufferedImage img) {
        this.img = img;
        if (img != null) {
            setPreferredSize(new Dimension(img.getWidth(), img.getHeight()));
        }
    }

    /**
     * Establece si tiene discontinuidad
     *
     * @param discontinua
     */
    public void setDiscontinua(boolean discontinua) {
        this.discontinua = discontinua;
        setTrazo(this.grosor);
    }

    /**
     *
     * Devuelve si tiene discontinuidad
     *
     * @return
     */
    public boolean getDiscontinua() {
        return discontinua;
    }

    /**
     * Establece el area delimitada en lienzo
     *
     * @param area_clip
     */
    public void setArea_clip(Shape area_clip) {
        this.area_clip = area_clip;
    }

    /**
     * Devuelve el area delimitada en lienzo
     *
     * @return
     */
    public Shape getArea_clip() {
        return area_clip;
    }

    /**
     * Establece el la figura los atributos actuales del lienzo
     *
     * @param forma figura a editar
     * @param fill si la figura tiene o no releno
     */
    public void setAtributos(FormasSM forma, boolean fill) {
        forma.setColor(color);
        forma.setTrazo(trazo);
        forma.setComp(comp);
        forma.setRender(render);
        forma.setDiscontinua(discontinua);
        forma.setAlisado(alisado);
        if (fill) {
            forma.setRelleno(relleno);
        }
    }

    /**
     * Devuelve la imagen del lienzo
     *
     * @param pintaVector
     * @return
     */
    public BufferedImage getImagen(boolean pintaVector) {
        if (pintaVector) {
            BufferedImage imgout = new BufferedImage(img.getWidth(),
                    img.getHeight(),
                    img.getType());
            boolean opacoActual = this.isOpaque();
            if (img.getColorModel().hasAlpha()) {
                this.setOpaque(false);
            }
            this.paint(imgout.createGraphics());
            this.setOpaque(opacoActual);
            return imgout;
        } else {
            return img;
        }
    }

    /**
     * Añadir listener al lienzo
     *
     * @param listener
     */
    public void addLienzoListener(LienzoListener listener) {
        if (listener != null) {
            lienzoEventListeners.add(listener);
        }
    }

    private void notifyShapeAddedEvent(LienzoEvent evt) {
        if (!lienzoEventListeners.isEmpty()) {
            for (LienzoListener listener : lienzoEventListeners) {
                listener.shapeAdded(evt);
            }
        }
    }

    private void notifyPropertyChangeEvent(LienzoEvent evt) {
        if (!lienzoEventListeners.isEmpty()) {
            for (LienzoListener listener : lienzoEventListeners) {
                listener.propertyChange(evt);
            }
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
